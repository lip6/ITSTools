package fr.lip6.move.gal.application.runner.its;

import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;

import fr.lip6.move.gal.Specification;
import fr.lip6.move.gal.application.mcc.MccTranslator;
import fr.lip6.move.gal.application.runner.Ender;
import fr.lip6.move.gal.application.runner.IRunner;
import fr.lip6.move.gal.instantiate.Instantiator;
import fr.lip6.move.gal.mcc.properties.DoneProperties;
import fr.lip6.move.gal.semantics.IDeterministicNextBuilder;
import fr.lip6.move.gal.semantics.INextBuilder;
import fr.lip6.move.gal.struct2gal.HLPNOrderComputer;
import fr.lip6.move.gal.struct2gal.SpecBuilder;
import fr.lip6.move.gal.struct2gal.StructuralReductionBuilder;
import fr.lip6.move.gal.structural.StructuralReduction;
import fr.lip6.move.gal.structural.StructuralToGreatSPN;

public class MultiOrderRunner {

	public static String computeOrderWithGreatSPN(String pwd, String gspnpath, String orderHeur, MccTranslator reader,
			String orderff) {
		if (orderHeur != null && gspnpath != null) {
			// No hierarchy in this path
			try {
	
				INextBuilder nb = INextBuilder.build(reader.getSpec());
				IDeterministicNextBuilder idnb = IDeterministicNextBuilder.build(nb);
				StructuralReduction sr = StructuralReductionBuilder.createStructuralReduction(idnb);
				StructuralToGreatSPN s2gspn = new StructuralToGreatSPN();
				String gspnmodelff = pwd + "/gspn";
				s2gspn.transform(sr, gspnmodelff);
				try {
					GreatSPNRunner pinvrun = new GreatSPNRunner(pwd, gspnmodelff, gspnpath + "/bin/pinvar", 30);
					pinvrun.run();
				} catch (TimeoutException e) {
					System.out.println("P-invariant computation with GreatSPN timed out. Skipping.");
				}
	
				GreatSPNRunner run = new GreatSPNRunner(pwd, gspnmodelff, gspnpath + "/bin/RGMEDD2", 60);
				run.configure("-" + orderHeur);
				run.configure("-varord-only");
				run.run();
				String[] order = run.getOrder();
	
				Specification reduced = SpecBuilder.rebuildSpecification(sr);
				reduced.getProperties().addAll(reader.getSpec().getProperties());
				Instantiator.normalizeProperties(reduced);
				reader.setSpec(reduced);
	
				orderff = pwd + "/" + "model.ord";
				PrintWriter out = new PrintWriter(new BufferedOutputStream(new FileOutputStream(orderff)));
				out.println("#TYPE " + reduced.getMain().getName());
				for (int i = 0; i < order.length; i++) {
					String var = order[i];
					out.println(var);
				}
				out.println("#END");
				out.flush();
				out.close();
	
				System.out.println("Using order generated by GreatSPN with heuristic : " + orderHeur);
			} catch (TimeoutException e) {
				System.out.println("Order computation with GreatSPN timed out. Skipping.");
			} catch (Exception e) {
	
				e.printStackTrace();
			}
		}
		return orderff;
	}

	public static  MccTranslator runMultiITS(String pwd, String examination, String gspnpath, String orderHeur, boolean doITS,
				boolean onlyGal, boolean doHierarchy, boolean useManyOrder, MccTranslator reader, DoneProperties doneProps,
				boolean useLouvain, long timeout, AtomicBoolean wasKilled, long startTime, List<IRunner> runners, Ender e) throws IOException, InterruptedException {
			
		if (!doITS && !onlyGal) {
			return reader;
		}
		
		MccTranslator reader2 = null;
			long elapsed = (startTime - System.currentTimeMillis()) / 1000;
			timeout -= elapsed;
			if (useManyOrder) {
				reader2 = reader.copy();
				timeout /= 3;
			} else {
				reader2 = reader;
			}
			if (reader.getSpec() == null) {
				reader.rebuildSpecification(doneProps);
			}
	
			if (!wasKilled.get() && (useLouvain || useManyOrder)) {
	//			if (useManyOrder)
	//				reader = reader2.copy();
				reader.getSpec().getProperties().removeIf(p -> doneProps.containsKey(p.getName()));
				reader.setLouvain(true);
				reader.setOrder(null);
				reader.flattenSpec(true);
	
				if (doITS || onlyGal) {
					// decompose + simplify as needed
					IRunner itsRunner = new ITSRunner(examination, reader, doITS, onlyGal, reader.getFolder(), timeout,
							null);
					startRunner(doITS, reader, doneProps, wasKilled, runners, e, itsRunner);
				}
	
			}
	
			if (!wasKilled.get() && (doITS || onlyGal) && (!useLouvain || useManyOrder)) {
				if (useManyOrder)
					reader = reader2.copy();
				reader.getSpec().getProperties().removeIf(p -> doneProps.containsKey(p.getName()));
				if (reader.getHLPN() != null) {
					reader.setOrder(HLPNOrderComputer.computeOrder(reader.getHLPN()));
				}
				reader.flattenSpec(true);
	
				if (doITS || onlyGal) {
					// decompose + simplify as needed
					IRunner itsRunner = new ITSRunner(examination, reader, doITS, onlyGal, reader.getFolder(), timeout,
							null);
					startRunner(doITS, reader, doneProps, wasKilled, runners, e, itsRunner);
				}
	
			}
	
			if (!wasKilled.get() && orderHeur != null && gspnpath != null) {
				if (useManyOrder)
					reader = reader2.copy();
	
				reader.flattenSpec(false);
				reader.getSpec().getProperties().removeIf(p -> doneProps.containsKey(p.getName()));
				String myOrderff = null;
				if (orderHeur != null) {
					myOrderff = computeOrderWithGreatSPN(pwd, gspnpath, orderHeur, reader, myOrderff);
				}
	
				if (doITS || onlyGal) {
					// decompose + simplify as needed
					IRunner itsRunner = new ITSRunner(examination, reader, doITS, onlyGal, reader.getFolder(), timeout,
							myOrderff);
					startRunner(doITS, reader, doneProps, wasKilled, runners, e, itsRunner);
				}
	
			}
	
			return reader;
		}

	public static void startRunner(boolean doITS, MccTranslator reader, DoneProperties doneProps,
			AtomicBoolean wasKilled, List<IRunner> runners, Ender e, IRunner itsRunner)
			throws IOException, InterruptedException {
		itsRunner.configure(reader.getSpec(), doneProps);
		if (doITS) {
			synchronized (e) {
				if (! wasKilled.get()) {
					runners.add(itsRunner);						
					itsRunner.solve(e);
				}
			}						
			itsRunner.join();
			
			runners.remove(itsRunner);
		}
	}

}
